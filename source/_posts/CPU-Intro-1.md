---
layout: post
title: CPU学习(一) 流水线与冒险
date: 2024-11-12 16:35:12
categories:
  - 计算机体系结构
tags:
  - CPU
  - 处理器
  - 流水线
  - 体系结构
---
# 前言

这个系列会记录一些关于通用处理器的学习总结, 不会包含特别深入的原理或实现, 主要是一些入门级别的学习.

# 关于CPU流水线

## 什么是指令流水线

为了加速CPU执行指令的速度, 现代CPU基本都拥有**指令流水线**, 大致思路是将单条指令执行按模块顺序排列, 依次执行, 这样可以
实现前一条指令还没执行完时, 后续指令就开始执行. 这样, 虽然单条指令的执行时间没有减少, 但是**指令执行的吞吐量增大了**.  
指令流水线具体的层数是可变的, 例如经典五层流水线结构如下:

- 取指级(IF)：取指令，输出next_pc。
- 译码级(ID)：译码，分配功能，获取源操作数。
- 执行级(EXE)：执行指令，计算结果。
- 访存级(MEM)：执行内存读写指令。
- 写回级(WB)：写回结果。
而Intel代号为Prescott的奔腾芯片, 流水线深度为31层, 目前常见的CPU流水线为14层左右.

## 流水线与性能

从上面看, 流水线能提升CPU的指令吞吐量, 那是不是CPU的流水线深度越高越好呢? 答案是否定的, 流水线对性能的影响是很复杂的,
例如:  
每层流水线都需要寄存器来储存这层流水线的计算结果, 因此增加流水线深度会增加CPU器件数量, 导致CPU功耗和成本上升; 同时
读写流水线寄存器也需要耗时, 意味着每添加一层流水线, 单条指令的执行时间都会增加一点.
还有, 由于流水线会出现**冒险**问题, 流水线理论的吞吐量提升在实际程序执行中往往达不到. 例如, 下面的三条指令:

```c
int a = 10 + 5;
int b = a + 3;
float c = b * 1.0f;
```

这三条指令, 指令二依赖指令一的结果, 同时指令三也依赖指令二的结果, 这种场景下, 指令流水线并不能达到理论的加速比.

# 流水线冒险

**流水线冒险(pipeline harzard)** 是指在流水线中, 某个模块下一个始终周期无法执行下一条指令的情况, 这一节会介绍流水线冒险
的具体场景, 以及一些常见的解决方案.

## 有哪些冒险?

- **数据冒险**: 我们在前面讨论流水线性能的时候举的例子就是数据冒险, 指的是后续指令依赖前面指令的数据结果, 那么后续指令必须等待依赖的
指令将计算结果写回内存/寄存器中才能执行读取操作.
- **结构冒险**: 多条指令要同时访问一个资源, 例如一条指令在取指级读取指令, 另一条指令在访存级读取寄存器, 无法同时执行.
- **控制冒险**: 决策依赖于前级指令的计算结果, 例如if语句, 需要等到if表达式的值计算完成后才能决定跳转到哪个分支执行.

## 如何处理冒险?

一般的方式就是插入**流水线气泡**, 可以**解决上面三种冒险**, 指令译码时, 如果发现可能存在冒险, 可以插入NOP指令, 使得有
风险的指令进入流水线时, 上条指令已经执行到冒险消失的阶段了. 取决于解决具体的冒险场景需要等待的流水线级数, 可能插入若干
个NOP. 如果插入等同于流水线级数的NOP指令, 相当于排空整个流水线, 这个操作称为`flush`.  
对于不同的冒险, 还有一些特定的优化方式, 下面分开讨论:

### 数据冒险

1. 编译期优化, 通过调整不相关的指令顺序, 可以解决一部分数据冒险的场景, 例如如下代码:

```c
a = b + c
d = e - f
```

如果不做优化, 会产生数据冒险:

```asm
lw $2, b
lw $3, c
add $1, $2, $3 // 依赖上一条指令 $3
sw a, $1 // 依赖上一条指令 $1
lw $5, e
lw $6, f
sub $4, $5, $6 // 依赖上一条指令 $6
sw d, $4 // 依赖上一条指令 $4
```

如果我们做如下优化:

```asm
lw $2, b
lw $3, c
lw $5, e // 这条指令上移, 不影响执行结果
add $1, $2, $3 // 对$3的数据冒险解除
lw $6, f // 这条指令上移, 不影响执行结果
sw a, $1 // 对$1的数据冒险解除
sub $4, $5, $6 // 对$6的数据冒险解除
sw d, $4 // 依赖上条指令 $4
```

可以看出, 通过优化指令执行顺序, 在不影响指令执行结果的情况下, 我们解决了部分数据冒险的场景.
> 根据统计, 不同编译器通过优化调度, 可以减少约1/3~1/2的数据冒险场景

2. 转发/旁路, 如果依赖的数据是ALU计算的结果, 虽然这个数据还没有写入内存/寄存器, 但是结果是存在于ALU之中的, 可以通过直接
从ALU中读取计算结果来解决数据冒险.

3. 阻塞, 通过以上两种方式优化后, 仍然有一部分数据冒险的场景无法解决, 这种场景只能通过插入流水线气泡阻塞流水线来解决.

### 结构冒险

结构冒险的解决相对简单, 主要有:

1. 功能部件在特定阶段才能使用(例如ALU只能在EXE级使用)
2. 将指令内存和数据内存分开, 解决取指令和读写数据的冲突(类似于哈佛结构, 现代CPU一般L1缓存分成指令和数据两部分).
3. 寄存器读口和写口分开, 支持同时读写.

### 控制冒险

1. 分支预测: 在尚未计算出执行哪个分支时, 先预测一个分支进行执行, 如果分支正确则能节省时间, 如果预测错误则从正确的分支地址
处重新执行
2. 延迟分支: 编译器优化, 将分支指令前面与分支指令无关的指令调到分支指令后面执行, 也叫做**延迟转移**
